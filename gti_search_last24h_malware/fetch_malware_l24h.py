#!/usr/bin/env python3
"""
GTI Sample Fetcher — Download or inspect malware samples from Google Threat Intelligence.

Requires a GTI/VirusTotal API key with premium (download) privileges.
Usage examples:
    python gti_sample.py -k YOUR_API_KEY -H HASH -i              # display report
    python gti_sample.py -k YOUR_API_KEY -H HASH -d              # download sample
    python gti_sample.py -k YOUR_API_KEY -H HASH -d -o ./samples # download to dir
    python gti_sample.py -k YOUR_API_KEY -H HASH -i -d           # both
"""

import argparse
import json
import os
import sys
from datetime import datetime, timezone

# requests is the only external dependency — used for all GTI API calls
try:
    import requests
except ImportError:
    sys.exit("[!] 'requests' library required.  Install with:  pip install requests")

# GTI uses the same v3 REST API base as VirusTotal
BASE_URL = "https://www.virustotal.com/api/v3"

# ── ANSI colour codes for terminal output ─────────────────────────────
# These make the report easier to scan visually; they're no-ops on
# redirected output since most pagers / files ignore ANSI escapes.
RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"


def _c(text: str, colour: str) -> str:
    """Wrap *text* in an ANSI colour sequence and reset afterwards."""
    return f"{colour}{text}{RESET}"


# ── API helpers ───────────────────────────────────────────────────────

def _headers(api_key: str) -> dict:
    """Return the standard auth + accept headers for GTI v3 endpoints."""
    return {"x-apikey": api_key, "Accept": "application/json"}


def get_file_report(api_key: str, file_hash: str) -> dict | None:
    """
    GET /files/{hash}  — retrieve the full GTI file object.

    Accepts MD5, SHA-1, or SHA-256 as the hash identifier.
    Returns the parsed JSON dict on success, or None on failure.
    """
    url = f"{BASE_URL}/files/{file_hash}"
    resp = requests.get(url, headers=_headers(api_key), timeout=30)

    if resp.status_code == 200:
        return resp.json()

    # Print the error body so the user can diagnose key / quota issues
    print(f"{_c('[!]', RED)} Failed to retrieve report — HTTP {resp.status_code}")
    try:
        print(json.dumps(resp.json(), indent=2))
    except Exception:
        print(resp.text)
    return None


def download_sample(api_key: str, file_hash: str, output_dir: str) -> str | None:
    """
    GET /files/{hash}/download — download the raw malware binary.

    This endpoint requires **premium / enterprise** API privileges.
    The API returns a 302 redirect to a time-limited GCS URL; requests
    follows it automatically with allow_redirects=True.

    Returns the local file path on success, or None on failure.
    """
    url = f"{BASE_URL}/files/{file_hash}/download"

    # Note: we don't send Accept: application/json here because the
    # response is the raw binary (or a redirect to it).
    resp = requests.get(
        url,
        headers={"x-apikey": api_key},
        timeout=120,           # generous timeout for large samples
        allow_redirects=True,  # follow the 302 → GCS signed URL
    )

    if resp.status_code != 200:
        print(f"{_c('[!]', RED)} Download failed — HTTP {resp.status_code}")
        try:
            print(json.dumps(resp.json(), indent=2))
        except Exception:
            print(resp.text)
        return None

    # Ensure the target directory tree exists before writing
    os.makedirs(output_dir, exist_ok=True)

    # Save using the hash as the filename (no extension — treat with care)
    dest = os.path.join(output_dir, file_hash)
    with open(dest, "wb") as fh:
        fh.write(resp.content)
    return dest


# ── Display / formatting helpers ──────────────────────────────────────

def _ts(epoch: int | None) -> str:
    """Convert a UNIX epoch timestamp to a human-readable UTC string."""
    if epoch is None:
        return "N/A"
    return datetime.fromtimestamp(epoch, tz=timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")


def display_report(data: dict) -> None:
    """
    Pretty-print a GTI file report to the terminal.

    Sections displayed:
      • Identification  — name, type, size, magic, submission dates
      • Hashes          — MD5, SHA-1, SHA-256, SSDEEP, TLSH, VHASH
      • Detection       — aggregate AV engine stats
      • Classification  — popular threat label / family
      • Sandbox Verdicts— per-sandbox category (malicious / suspicious / etc.)
      • Tags            — GTI-assigned tags
      • Links           — direct URL to the GTI web UI
    """
    # All interesting fields live under data → attributes
    attrs = data.get("data", {}).get("attributes", {})

    # ── header ────────────────────────────────────────────────────────
    print(f"\n{'═' * 72}")
    print(_c("  GTI / VirusTotal File Report", BOLD + CYAN))
    print(f"{'═' * 72}")

    # ── identification section ────────────────────────────────────────
    # meaningful_name is the best human-readable name GTI picks;
    # fall back to the first entry in the names array if absent.
    name = attrs.get("meaningful_name")
    if not name:
        names_list = attrs.get("names", [])
        name = names_list[0] if names_list else "N/A"

    print(_c("\n▸ Identification", BOLD))
    print(f"  {'Name':<22} {name}")
    print(f"  {'Type':<22} {attrs.get('type_description', 'N/A')}  ({attrs.get('type_tag', '')})")
    print(f"  {'Size':<22} {attrs.get('size', 0):,} bytes")
    print(f"  {'Magic':<22} {attrs.get('magic', 'N/A')}")
    print(f"  {'First Submission':<22} {_ts(attrs.get('first_submission_date'))}")
    print(f"  {'Last Analysis':<22} {_ts(attrs.get('last_analysis_date'))}")

    # ── hashes section ────────────────────────────────────────────────
    print(_c("\n▸ Hashes", BOLD))
    print(f"  {'MD5':<22} {attrs.get('md5', 'N/A')}")
    print(f"  {'SHA-1':<22} {attrs.get('sha1', 'N/A')}")
    print(f"  {'SHA-256':<22} {attrs.get('sha256', 'N/A')}")
    print(f"  {'SSDEEP':<22} {attrs.get('ssdeep', 'N/A')}")       # fuzzy hash
    print(f"  {'TLSH':<22} {attrs.get('tlsh', 'N/A')}")           # trend micro locality-sensitive hash
    print(f"  {'VHASH':<22} {attrs.get('vhash', 'N/A')}")         # VT's own similarity hash

    # ── detection stats ───────────────────────────────────────────────
    # last_analysis_stats is an aggregate of all AV engine results
    stats = attrs.get("last_analysis_stats", {})
    malicious  = stats.get("malicious", 0)
    suspicious = stats.get("suspicious", 0)
    undetected = stats.get("undetected", 0)
    harmless   = stats.get("harmless", 0)
    total      = malicious + suspicious + undetected + harmless  # excludes timeout/unsupported

    det_colour = RED if malicious > 0 else GREEN
    print(_c("\n▸ Detection", BOLD))
    print(f"  {_c(f'{malicious}/{total}', det_colour)} engines flagged malicious")
    print(f"  {'Malicious':<14} {_c(str(malicious), RED)}")
    print(f"  {'Suspicious':<14} {_c(str(suspicious), YELLOW)}")
    print(f"  {'Undetected':<14} {undetected}")
    print(f"  {'Harmless':<14} {_c(str(harmless), GREEN)}")

    # ── popular threat classification ─────────────────────────────────
    # GTI aggregates vendor labels into a "popular" consensus classification
    ptc = attrs.get("popular_threat_classification", {})
    if ptc:
        label = ptc.get("suggested_threat_label", "N/A")
        print(_c("\n▸ Threat Classification", BOLD))
        print(f"  {'Label':<22} {_c(label, YELLOW)}")

        # top categories (e.g. trojan, ransomware, worm)
        cats = ptc.get("popular_threat_category", [])
        if cats:
            print(f"  {'Categories':<22} {', '.join(c.get('value', '') for c in cats)}")

        # top family names (e.g. emotet, cobalt-strike)
        names = ptc.get("popular_threat_name", [])
        if names:
            print(f"  {'Names':<22} {', '.join(n.get('value', '') for n in names)}")

    # ── sandbox verdicts ──────────────────────────────────────────────
    # Each sandbox that detonated the sample provides its own verdict
    verdicts = attrs.get("sandbox_verdicts", {})
    if verdicts:
        print(_c("\n▸ Sandbox Verdicts", BOLD))
        for sandbox, info in verdicts.items():
            category = info.get("category", "N/A")
            v_colour = RED if "malicious" in category.lower() else YELLOW
            print(f"  {sandbox:<30} {_c(category, v_colour)}")

    # ── tags ──────────────────────────────────────────────────────────
    # Tags are short labels like "peexe", "upx", "signed", etc.
    tags = attrs.get("tags", [])
    if tags:
        print(_c("\n▸ Tags", BOLD))
        print(f"  {', '.join(tags)}")

    # ── direct link to the GTI web console ────────────────────────────
    sha256 = attrs.get("sha256", "")
    if sha256:
        print(_c("\n▸ Links", BOLD))
        print(f"  GTI:  https://www.virustotal.com/gui/file/{sha256}")

    print(f"\n{'═' * 72}\n")


# ── CLI entry point ───────────────────────────────────────────────────

def main() -> None:
    parser = argparse.ArgumentParser(
        description="Fetch or download malware samples from Google Threat Intelligence (GTI / VirusTotal).",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="Examples:\n"
               "  %(prog)s -k API_KEY -H SHA256 -i\n"
               "  %(prog)s -k API_KEY -H SHA256 -d -o ./samples\n"
               "  %(prog)s -k API_KEY -H SHA256 -i -d\n",
    )

    # ── required arguments ────────────────────────────────────────────
    parser.add_argument("-k", "--key",      required=True,  help="GTI / VirusTotal API key")
    parser.add_argument("-H", "--hash",     required=True,  help="File hash (MD5, SHA-1, or SHA-256)")

    # ── action flags (at least one is required) ───────────────────────
    parser.add_argument("-i", "--info",     action="store_true", help="Display the file report")
    parser.add_argument("-d", "--download", action="store_true", help="Download the sample binary")

    # ── optional modifiers ────────────────────────────────────────────
    parser.add_argument("-o", "--output",   default="./downloads", help="Output directory for downloads (default: ./downloads)")
    parser.add_argument("-j", "--json",     action="store_true",   help="Dump the raw JSON report instead of pretty output")
    parser.add_argument("-q", "--quiet",    action="store_true",   help="Suppress banner / decorative output")

    args = parser.parse_args()

    # Guard: user must pick at least one action
    if not args.info and not args.download:
        parser.error("Specify at least one action:  -i (info)  and/or  -d (download)")

    file_hash = args.hash.strip()

    # ── info / display ────────────────────────────────────────────────
    if args.info:
        if not args.quiet:
            print(f"\n{_c('[*]', CYAN)} Fetching report for {_c(file_hash, BOLD)} …")

        report = get_file_report(args.key, file_hash)
        if report is None:
            sys.exit(1)  # error details already printed by get_file_report()

        if args.json:
            # Raw JSON mode — useful for piping into jq or other tools
            print(json.dumps(report, indent=2, sort_keys=True))
        else:
            display_report(report)

    # ── download ──────────────────────────────────────────────────────
    if args.download:
        if not args.quiet:
            print(f"{_c('[*]', CYAN)} Downloading sample {_c(file_hash, BOLD)} …")

        path = download_sample(args.key, file_hash, args.output)
        if path is None:
            sys.exit(1)  # error details already printed by download_sample()

        size = os.path.getsize(path)
        print(f"{_c('[✓]', GREEN)} Saved → {_c(path, BOLD)}  ({size:,} bytes)")

        # Safety reminder — this file is (likely) live malware
        print(f"\n{_c('⚠  CAUTION:', YELLOW + BOLD)} This file may be live malware. "
              f"Handle in an isolated environment.\n")


if __name__ == "__main__":
    main()

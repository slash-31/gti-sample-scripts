#!/usr/bin/env python3
"""
GTI Threat List Fetcher — Pull the latest Categorised Threat Lists from
Google Threat Intelligence (GTI / VirusTotal) via the v3 API.

The Categorised Threat Lists endpoint provides IoCs (files, URLs, domains,
IP addresses) grouped by threat category.  Lists are generated hourly with
a ~2-hour lag from the current UTC time.

Docs: https://gtidocs.virustotal.com/reference/get-latest-threat-list

Usage examples:
    # Fetch the latest ransomware file IoCs as pretty-printed JSON
    python fetch_malware_l24h.py -k API_KEY -l ransomware -t file -i

    # Download malware IoCs in CSV format to a file
    python fetch_malware_l24h.py -k API_KEY -l malware -t file -f csv -o malware_iocs.csv

    # Fetch phishing URLs in STIX format
    python fetch_malware_l24h.py -k API_KEY -l phishing -t url -f stix

    # Filter: files with malware families, 10+ detections, GTI score ≥ 50
    python fetch_malware_l24h.py -k API_KEY -l malware -t file \\
        --has malware_families --positives 10+ --gti-score 50+

    # Download samples from the fetched threat list
    python fetch_malware_l24h.py -k API_KEY -l ransomware -t file -d -O ./samples
"""

import argparse
import json
import os
import sys
import urllib.parse
from datetime import datetime, timezone

# requests is the only external dependency
try:
    import requests
except ImportError:
    sys.exit("[!] 'requests' library required.  Install with:  pip install requests")

# ── Constants ─────────────────────────────────────────────────────────

# GTI uses the same v3 REST API base URL as VirusTotal
BASE_URL = "https://www.virustotal.com/api/v3"

# All available Categorised Threat List IDs and their supported IoC types.
# Licence tiers: All = all paid licences, E = Enterprise, EP = Enterprise Plus
THREAT_LISTS = {
    "ransomware":                    {"types": ["file"],                                  "licence": "All"},
    "malicious-network-infrastructure": {"types": ["url", "domain", "ip_address"],        "licence": "All"},
    "malware":                       {"types": ["file", "url", "domain", "ip_address"],   "licence": "E / EP"},
    "threat-actor":                  {"types": ["file", "url", "domain", "ip_address"],   "licence": "E / EP"},
    "trending":                      {"types": ["file", "url", "domain", "ip_address"],   "licence": "E / EP"},
    "mobile":                        {"types": ["file"],                                  "licence": "EP"},
    "osx":                           {"types": ["file"],                                  "licence": "EP"},
    "linux":                         {"types": ["file"],                                  "licence": "EP"},
    "iot":                           {"types": ["file"],                                  "licence": "EP"},
    "cryptominer":                   {"types": ["file", "url", "domain", "ip_address"],   "licence": "EP"},
    "phishing":                      {"types": ["url", "domain", "ip_address"],           "licence": "EP"},
    "first-stage-delivery-vectors":  {"types": ["file"],                                  "licence": "EP"},
    "vulnerability-weaponization":   {"types": ["file", "url", "domain", "ip_address"],   "licence": "EP"},
    "infostealer":                   {"types": ["file"],                                  "licence": "EP"},
}

# Supported export formats for the API
FORMATS = ["json", "csv", "stix", "stix-sentinel", "misp"]

# Supported IoC types that can be passed in the 'type' query parameter
IOC_TYPES = ["file", "url", "domain", "ip_address"]

# ── ANSI colour helpers ───────────────────────────────────────────────
RED    = "\033[91m"
GREEN  = "\033[92m"
YELLOW = "\033[93m"
CYAN   = "\033[96m"
BOLD   = "\033[1m"
RESET  = "\033[0m"


def _c(text: str, colour: str) -> str:
    """Wrap *text* in an ANSI colour sequence."""
    return f"{colour}{text}{RESET}"


# ── API helpers ───────────────────────────────────────────────────────

def _headers(api_key: str) -> dict:
    """Standard auth + accept headers for all GTI v3 calls."""
    return {"x-apikey": api_key, "Accept": "application/json"}


def build_query_string(args: argparse.Namespace) -> str:
    """
    Assemble the optional 'query' parameter from CLI filter flags.

    Supported modifiers (per the API docs):
      - gti_score:<n>+  /  gti_score:<n>-  /  gti_score:<n>
      - positives:<n>+  /  positives:<n>-  /  positives:<n>
      - has:malware_families
      - has:campaigns
      - has:reports
      - has:threat_actors

    Returns an empty string if no filters are specified.
    """
    parts = []

    # --gti-score  e.g. "50+" or "30-" or "1"
    if args.gti_score:
        parts.append(f"gti_score:{args.gti_score}")

    # --positives  e.g. "10+" or "5-"
    if args.positives:
        parts.append(f"positives:{args.positives}")

    # --has  list of relationship modifiers (malware_families, campaigns, etc.)
    if args.has:
        for h in args.has:
            parts.append(f"has:{h}")

    # Join with spaces — the API treats spaces as implicit AND
    return " ".join(parts)


def fetch_threat_list(
    api_key: str,
    list_id: str,
    ioc_type: str | None = None,
    fmt: str = "json",
    limit: int | None = None,
    query: str = "",
) -> requests.Response:
    """
    GET /threat_lists/{threat_list_id}/latest

    Fetches the most recent hourly IoC package for the given threat list.
    Returns the raw requests.Response so the caller can handle both JSON
    and binary (CSV/STIX/MISP) formats.
    """
    # Build the endpoint URL
    url = f"{BASE_URL}/threat_lists/{list_id}/latest"

    # Assemble query parameters — only include non-empty values
    params: dict[str, str] = {}
    if ioc_type:
        params["type"] = ioc_type          # e.g. "file" or "file,url"
    if fmt and fmt != "json":
        params["format"] = fmt             # json is the default, no need to send
    if limit:
        params["limit"] = str(limit)
    if query:
        # The API requires URL-encoding of special chars like : and +
        params["query"] = query

    resp = requests.get(url, headers=_headers(api_key), params=params, timeout=60)
    return resp


def download_sample(api_key: str, file_hash: str, output_dir: str) -> str | None:
    """
    GET /files/{hash}/download — download a raw malware binary.

    Requires premium / enterprise API privileges.
    The API returns a 302 redirect to a time-limited GCS signed URL.
    Returns the saved file path on success, or None on failure.
    """
    url = f"{BASE_URL}/files/{file_hash}/download"
    resp = requests.get(
        url,
        headers={"x-apikey": api_key},
        timeout=120,
        allow_redirects=True,    # follow 302 → signed GCS URL
    )
    if resp.status_code != 200:
        print(f"  {_c('[!]', RED)} Download failed for {file_hash} — HTTP {resp.status_code}")
        return None

    os.makedirs(output_dir, exist_ok=True)
    dest = os.path.join(output_dir, file_hash)
    with open(dest, "wb") as fh:
        fh.write(resp.content)
    return dest


# ── Display helpers ───────────────────────────────────────────────────

def _ts(epoch: int | None) -> str:
    """Convert a UNIX epoch to a readable UTC string."""
    if epoch is None:
        return "N/A"
    return datetime.fromtimestamp(epoch, tz=timezone.utc).strftime("%Y-%m-%d %H:%M UTC")


def _verdict_colour(verdict: str) -> str:
    """Map a GTI verdict string to an ANSI colour."""
    v = verdict.upper()
    if "MALICIOUS" in v:
        return RED
    if "SUSPICIOUS" in v:
        return YELLOW
    if "BENIGN" in v or "HARMLESS" in v:
        return GREEN
    return RESET


def display_ioc_summary(iocs: list[dict]) -> None:
    """
    Pretty-print a summary table of IoCs returned by the threat list endpoint.
    Each IoC's data lives under ioc["data"]["attributes"].
    """
    print(f"\n{'═' * 100}")
    print(_c("  GTI Categorised Threat List — IoC Summary", BOLD + CYAN))
    print(f"{'═' * 100}")
    print(f"  {_c('Total IoCs returned:', BOLD)} {len(iocs)}\n")

    # Column header
    print(f"  {'#':<4} {'Type':<12} {'ID / Hash':<68} {'GTI':<6} {'AV+':<5} {'Verdict'}")
    print(f"  {'─'*4} {'─'*12} {'─'*68} {'─'*6} {'─'*5} {'─'*20}")

    for idx, ioc in enumerate(iocs, start=1):
        data  = ioc.get("data", {})
        attrs = data.get("attributes", {})
        ioc_type = data.get("type", "?")
        ioc_id   = data.get("id", "?")

        # GTI assessment fields
        gti       = attrs.get("gti_assessment", {})
        score     = gti.get("threat_score", {}).get("value", "?")
        verdict   = gti.get("verdict", {}).get("value", "?")
        positives = attrs.get("positives", "?")

        # Short, human-readable verdict (strip the VERDICT_ prefix)
        v_short = str(verdict).replace("VERDICT_", "").lower()
        v_colour = _verdict_colour(str(verdict))

        # Truncate ID if too long (SHA-256 hashes are 64 chars, URLs can be longer)
        display_id = ioc_id if len(ioc_id) <= 66 else ioc_id[:63] + "..."

        print(f"  {idx:<4} {ioc_type:<12} {display_id:<68} {str(score):<6} {str(positives):<5} {_c(v_short, v_colour)}")

    print(f"\n{'═' * 100}")


def display_ioc_detail(ioc: dict, idx: int) -> None:
    """Print a detailed view of a single IoC with relationships."""
    data  = ioc.get("data", {})
    attrs = data.get("attributes", {})
    rels  = data.get("relationships", {})

    ioc_type = data.get("type", "?")
    ioc_id   = data.get("id", "?")

    # GTI assessment
    gti     = attrs.get("gti_assessment", {})
    score   = gti.get("threat_score", {}).get("value", "?")
    verdict = gti.get("verdict", {}).get("value", "?")
    severity = gti.get("severity", {}).get("value", "?")

    v_colour = _verdict_colour(str(verdict))

    print(f"\n  ┌─ IoC #{idx} {'─' * 60}")
    print(f"  │ Type:       {ioc_type}")
    print(f"  │ ID:         {ioc_id}")

    # Show type-specific attributes
    if ioc_type == "file":
        print(f"  │ Name:       {attrs.get('meaningful_name', 'N/A')}")
        print(f"  │ MD5:        {attrs.get('md5', 'N/A')}")
    elif ioc_type == "url":
        print(f"  │ URL:        {attrs.get('url', 'N/A')}")
        print(f"  │ Title:      {attrs.get('title', 'N/A')}")
    elif ioc_type == "domain":
        print(f"  │ TLD:        {attrs.get('tld', 'N/A')}")
    elif ioc_type == "ip_address":
        print(f"  │ ASN:        {attrs.get('asn', 'N/A')} ({attrs.get('as_owner', '')})")
        print(f"  │ Country:    {attrs.get('country', 'N/A')}")

    # Common fields
    print(f"  │ GTI Score:  {score}   Verdict: {_c(str(verdict).replace('VERDICT_', ''), v_colour)}   Severity: {str(severity).replace('SEVERITY_', '')}")
    print(f"  │ AV+:        {attrs.get('positives', 'N/A')}")

    # Tags
    tags = attrs.get("tags", [])
    if tags:
        print(f"  │ Tags:       {', '.join(tags)}")

    # Relationships (malware families, threat actors, campaigns, reports)
    for rel_name in ["malware_families", "threat_actors", "campaigns", "reports"]:
        rel_data = rels.get(rel_name, {}).get("data", [])
        if rel_data:
            names = [r.get("attributes", {}).get("name", r.get("id", "?")) for r in rel_data]
            label = rel_name.replace("_", " ").title()
            print(f"  │ {label}: {', '.join(names)}")

    print(f"  └{'─' * 70}")


# ── Main CLI ──────────────────────────────────────────────────────────

def main() -> None:
    parser = argparse.ArgumentParser(
        description="Fetch the latest GTI Categorised Threat List and optionally download samples.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=(
            "Available Threat Lists:\n"
            "  ransomware                     Files — All licences\n"
            "  malicious-network-infrastructure  URLs, domains, IPs — All licences\n"
            "  malware                        Files, URLs, domains, IPs — Enterprise\n"
            "  threat-actor                   Files, URLs, domains, IPs — Enterprise\n"
            "  trending                       Files, URLs, domains, IPs — Enterprise\n"
            "  mobile                         Files — Enterprise Plus\n"
            "  osx                            Files — Enterprise Plus\n"
            "  linux                          Files — Enterprise Plus\n"
            "  iot                            Files — Enterprise Plus\n"
            "  cryptominer                    Files, URLs, domains, IPs — Enterprise Plus\n"
            "  phishing                       URLs, domains, IPs — Enterprise Plus\n"
            "  first-stage-delivery-vectors   Files — Enterprise Plus\n"
            "  vulnerability-weaponization    Files, URLs, domains, IPs — Enterprise Plus\n"
            "  infostealer                    Files — Enterprise Plus\n"
            "\nExamples:\n"
            "  %(prog)s -k KEY -l ransomware -t file -i\n"
            "  %(prog)s -k KEY -l malware -t file -f csv -o malware.csv\n"
            "  %(prog)s -k KEY -l malware -t file --has malware_families --positives 10+ --gti-score 50+\n"
            "  %(prog)s -k KEY -l ransomware -t file -d -O ./samples\n"
        ),
    )

    # ── required ──────────────────────────────────────────────────────
    parser.add_argument("-k", "--key",  required=True, help="GTI / VirusTotal API key")
    parser.add_argument("-l", "--list", required=True, choices=list(THREAT_LISTS.keys()),
                        metavar="LIST_ID", help="Threat list ID (see list below)")

    # ── IoC type filter ───────────────────────────────────────────────
    parser.add_argument("-t", "--type", default=None,
                        help="IoC type filter: file, url, domain, ip_address (comma-separated for multiple)")

    # ── output format ─────────────────────────────────────────────────
    parser.add_argument("-f", "--format", default="json", choices=FORMATS,
                        help="Export format (default: json)")

    # ── display / save options ────────────────────────────────────────
    parser.add_argument("-i", "--info",    action="store_true", help="Display a formatted IoC summary table")
    parser.add_argument("-v", "--verbose", action="store_true", help="Show detailed per-IoC breakdown (implies -i)")
    parser.add_argument("-o", "--output",  default=None,        help="Save raw API response to a file")
    parser.add_argument("-n", "--limit",   type=int, default=None, help="Max number of IoCs to return")
    parser.add_argument("-j", "--json",    action="store_true", help="Print raw JSON to stdout (default if no flags)")

    # ── query filters ─────────────────────────────────────────────────
    parser.add_argument("--gti-score", default=None,
                        help="GTI score filter, e.g. '50+', '30-', or '1'")
    parser.add_argument("--positives", default=None,
                        help="AV detection count filter, e.g. '10+', '5-'")
    parser.add_argument("--has", nargs="+", default=None,
                        choices=["malware_families", "campaigns", "reports", "threat_actors"],
                        help="Require IoCs to have these relationships")

    # ── download mode ─────────────────────────────────────────────────
    parser.add_argument("-d", "--download", action="store_true",
                        help="Download file samples from the threat list (files only, premium required)")
    parser.add_argument("-O", "--download-dir", default="./downloads",
                        help="Directory for downloaded samples (default: ./downloads)")

    # ── misc ──────────────────────────────────────────────────────────
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress banners")

    args = parser.parse_args()

    # verbose implies info display
    if args.verbose:
        args.info = True

    # ── Build the query filter string ─────────────────────────────────
    query = build_query_string(args)

    # ── Fetch the threat list ─────────────────────────────────────────
    if not args.quiet:
        print(f"\n{_c('[*]', CYAN)} Fetching threat list {_c(args.list, BOLD)}"
              f"{' type=' + args.type if args.type else ''}"
              f"{' format=' + args.format if args.format != 'json' else ''}"
              f"{' query=' + query if query else ''}"
              f" …")

    resp = fetch_threat_list(
        api_key=args.key,
        list_id=args.list,
        ioc_type=args.type,
        fmt=args.format,
        limit=args.limit,
        query=query,
    )

    # ── Handle errors ─────────────────────────────────────────────────
    if resp.status_code != 200:
        print(f"{_c('[!]', RED)} API returned HTTP {resp.status_code}")
        try:
            print(json.dumps(resp.json(), indent=2))
        except Exception:
            print(resp.text[:500])
        sys.exit(1)

    # ── Save to file if requested ─────────────────────────────────────
    if args.output:
        with open(args.output, "w", encoding="utf-8") as fh:
            fh.write(resp.text)
        print(f"{_c('[✓]', GREEN)} Saved response → {_c(args.output, BOLD)}  ({len(resp.text):,} bytes)")

    # ── JSON display modes ────────────────────────────────────────────
    if args.format == "json":
        data = resp.json()
        iocs = data.get("iocs", [])

        if not args.quiet:
            print(f"{_c('[✓]', GREEN)} Received {_c(str(len(iocs)), BOLD)} IoCs")

        # Pretty summary table
        if args.info and iocs:
            display_ioc_summary(iocs)

        # Detailed per-IoC view
        if args.verbose and iocs:
            for idx, ioc in enumerate(iocs, start=1):
                display_ioc_detail(ioc, idx)

        # Raw JSON dump (default fallback if no other display selected)
        if args.json or (not args.info and not args.output):
            print(json.dumps(data, indent=2, sort_keys=False))

        # ── Download file samples ─────────────────────────────────────
        if args.download:
            # Filter to file-type IoCs only — can't download URLs/domains/IPs
            file_iocs = [
                ioc for ioc in iocs
                if ioc.get("data", {}).get("type") == "file"
            ]
            if not file_iocs:
                print(f"{_c('[!]', YELLOW)} No file-type IoCs found in the response to download.")
            else:
                print(f"\n{_c('[*]', CYAN)} Downloading {len(file_iocs)} sample(s) to {_c(args.download_dir, BOLD)} …\n")
                success = 0
                for ioc in file_iocs:
                    sha256 = ioc["data"]["id"]
                    name   = ioc["data"].get("attributes", {}).get("meaningful_name", "")
                    label  = f"{name} ({sha256[:16]}…)" if name else sha256[:32] + "…"
                    print(f"  ↓ {label}", end="  ", flush=True)

                    path = download_sample(args.key, sha256, args.download_dir)
                    if path:
                        size = os.path.getsize(path)
                        print(f"{_c('✓', GREEN)} {size:,} bytes")
                        success += 1
                    else:
                        print(f"{_c('✗', RED)}")

                print(f"\n{_c('[✓]', GREEN)} Downloaded {success}/{len(file_iocs)} samples")
                print(f"\n{_c('⚠  CAUTION:', YELLOW + BOLD)} Downloaded files may be live malware. "
                      f"Handle in an isolated environment.\n")

    else:
        # Non-JSON formats (CSV, STIX, MISP) — just print or it's already saved
        if not args.output:
            print(resp.text)


if __name__ == "__main__":
    main()
